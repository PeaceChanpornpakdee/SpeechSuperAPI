<script type="text/javascript" src="sha.js"></script>
<script type="text/javascript" src="key.js"></script>
<script type="text/javascript" src="mockdata.js"></script>
<script src="https://cdn.rawgit.com/mattdiamond/Recorderjs/08e7abd9/dist/recorder.js"></script>
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<h2>-----------javascript http sample-----------</h2>
<form action="" method="post" enctype="multipart/form-data" id="form" name="form_en">
<pre>
refText: Test One Two Three
</pre>
<input type="file" name="audio" id="picpath" style="display:none" onChange="document.form_en.path.value=this.value">
<input name="path" readonly placeholder="Please choose your audio file" style="width:350px"> 
<input type="button" value="Browse" onclick="document.form_en.picpath.click()">
<pre>
<input type="submit" value="Submit" id ="btn" style="margin-left: 56px;">
</pre>
</form>

<button type="button" onclick="mock()">Mock Response</button>
<pre></pre>

<button type="button" class="recording-button" id="startRecording" onclick="startRecording()">Start Recording</button>
<button type="button" class="recording-button" id="stopRecording"  onclick="stopRecording()" disabled>Stop Recording</button>
<pre></pre>

<button type="button" onclick="downloadRecording()">Download</button>
<pre></pre>

<div id="firstclassenglish-popup"></div>
<script>

	function createPopup(results){
		var popup = document.getElementById("firstclassenglish-popup"); 
		console.log("Result", results);
		const title = document.createElement('h3');
		title.textContent = 'Pronunciation Score';
		popup.appendChild(title);
		createPowerbar(container=popup, topic='Fluency', percent=results.result.fluency);
		createPowerbar(container=popup, topic='Integrity', percent=results.result.integrity);
		createPowerbar(container=popup, topic='Rhythm', percent=results.result.rhythm);
		createTable(container=popup, results=results);
	}

	function createPowerbar(container, topic, percent) {
		const powerBarContainer = document.createElement('div');
		powerBarContainer.classList.add('power-bar-container');

		const powerBarBackground = document.createElement('div');
		powerBarBackground.classList.add('power-bar-background')

		const powerBar = document.createElement('div');
		powerBar.classList.add('power-bar')
		powerBar.style.width = percent + '%';

		const percentText = document.createElement('div');
		percentText.style.padding = '7px 4px';
		percentText.style.width = '12px'
		percentText.textContent = percent;

		const topicText = document.createElement('div');
		topicText.classList.add('power-bar-topic')
		topicText.textContent = topic;

		container.appendChild(powerBarContainer);
		powerBarContainer.appendChild(topicText);
		powerBarContainer.appendChild(powerBarBackground);
		powerBarBackground.appendChild(powerBar);
		powerBarContainer.appendChild(percentText);
	}

	function createTable(container, results){

		var table = document.createElement('table');

		var tableHead = document.createElement('thead');
		var tableBody = document.createElement('tbody');

		var headerRow = document.createElement('tr');
		var headers = ['Word', 'Score', ''];

		headers.forEach(headerText => {
			const th = document.createElement('th');
			th.textContent = headerText;
			headerRow.appendChild(th);
		});

		tableHead.appendChild(headerRow);
		table.appendChild(tableHead);

		const wordResult = results.result.words;

		for (let i = 0; i < wordResult.length; i++) {
			const row = document.createElement('tr');

			console.log(wordResult[i].word, wordResult[i].scores.overall);

			const cell1 = document.createElement('td');
			cell1.textContent = wordResult[i].word;

			const cell2 = document.createElement('td');
			cell2.textContent = wordResult[i].scores.overall;

			const cell3 = document.createElement('td');
			const arrowIcon = document.createElement('i');
			arrowIcon.classList.add('fas', 'fa-chevron-down'); 
			cell3.appendChild(arrowIcon);

			row.appendChild(cell1);
			row.appendChild(cell2);
			row.appendChild(cell3);
			row.addEventListener('click', () => toggleRows(`main-row-${i + 1}`, arrowIcon));

			row.classList.add(`main-row-${i + 1}`);

			if (i%2 === 0)  row.classList.add('main-even-row');
			else            row.classList.add('main-odd-row');

			tableBody.appendChild(row);

			const phonemes = wordResult[i].phonemes;

			for (let j = 0; j < phonemes.length; j++) {
				const subRow = document.createElement('tr');

				const cell11 = document.createElement('td');
				cell11.textContent = phonemes[j].phoneme;
				subRow.appendChild(cell11); 

				const cell22 = document.createElement('td');
				cell22.textContent = phonemes[j].pronunciation;
				subRow.appendChild(cell22);

				if(phonemes[j].pronunciation < 50){
					cell11.style.color = '#D90000';
					cell22.style.color = '#D90000';
				}

				console.log(phonemes[j].phoneme, phonemes[j].pronunciation);

				const cell33 = document.createElement('td');
				subRow.appendChild(cell33);

				subRow.classList.add(`main-row-${i + 1}-sub`);
				subRow.classList.add('hidden');

				if (j%2 === 0)  subRow.classList.add('even-row');
				else            subRow.classList.add('odd-row');
				
				tableBody.appendChild(subRow);
			}
		}

		table.appendChild(tableBody);
		container.appendChild(table);
	}

	function toggleRows(mainRowClass, arrowIcon) {
		const rowsToToggle = document.querySelectorAll(`.${mainRowClass}-sub`);
		rowsToToggle.forEach(row => {
			row.classList.toggle('show');
			row.classList.toggle('hidden');
		});	

		arrowIcon.classList.toggle('fa-chevron-down');
		arrowIcon.classList.toggle('fa-chevron-up');

		const otherMainRows = document.querySelectorAll(`tr[class^="main-row-"]:not(.${mainRowClass}):not([class*="sub"])`);

		otherMainRows.forEach(row => {
			const subRows = document.querySelectorAll(`.${row.classList[0]}-sub`);
			subRows.forEach(subRow => {
				subRow.classList.remove('show');
				subRow.classList.add('hidden');
			});
		});

		const otherArrowIcons = document.querySelectorAll(`tr[class^="main-row-"]:not(.${mainRowClass}) td:last-child i`);
		otherArrowIcons.forEach(icon => {
			icon.classList.add('fa-chevron-down');
			icon.classList.remove('fa-chevron-up');
		});
	}

	var baseUrl = "https://api.speechsuper.com/";

	var appKey = Key.appKey;
	var secretKey = Key.secretKey;

	var coreType = "sent.eval"; 
	// var refText = "Supermarket";
	var refText = "Test One Two Three";
	var audioType = "wav"; 
	var sampleRate = 16000;
	var userId = "guest";

	var url = baseUrl + coreType;
	
	var getConnectSig = function () {
		var timestamp = new Date().getTime().toString();
		var sig = new jsSHA(appKey + timestamp + secretKey, 'TEXT').getHash("SHA-1", "HEX");
		return { sig: sig, timestamp: timestamp };
	}
	var getStartSig = function () {
		var timestamp = new Date().getTime().toString();
		var sig = new jsSHA(appKey + timestamp + userId + secretKey, 'TEXT').getHash("SHA-1", "HEX");
		return { sig: sig, timestamp: timestamp, userId: userId };
	}
	var createUUID = (function (uuidRegEx, uuidReplacer) {
		return function () {
			return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
		};
	})(/[xy]/g, function (c) {
		var r = Math.random() * 16 | 0,
			v = c == "x" ? r : (r & 3 | 8);
		return v.toString(16);
	});
	var connectSig = getConnectSig();
	var startSig = getStartSig();
	var params = {
		connect: {
			cmd: "connect",
			param: {
				sdk: {
					version: 16777472,
					source: 9,
					protocol: 2
				},
				app: {
					applicationId: appKey,
					sig: connectSig.sig,
					timestamp: connectSig.timestamp
				}
			}
		},
		start: {
			cmd: "start",
			param: {
				app: {
					applicationId: appKey,
					sig: startSig.sig,
					userId: startSig.userId,
					timestamp: startSig.timestamp
				},
				audio: {
					audioType: audioType,
					sampleRate: sampleRate,
					channel: 1,
					sampleBytes: 2
				},
				request: {
					coreType: coreType,
					refText: refText,
					tokenId: createUUID()
				}
			}
		}
	};

	async function speechSuperAPI() {
		return new Promise(function(resolve, reject) {
			var fd = new FormData(document.getElementById("form"));
			fd.append("text", JSON.stringify(params));
			var xhr = new XMLHttpRequest();
			xhr.open("post", url);
			xhr.setRequestHeader("Request-Index", "0");
			xhr.send(fd);
			var t1, t2;
			t1 = Math.round(new Date().getTime() / 1000);
			xhr.onreadystatechange = function() {
			if (xhr.readyState == 4) {
				t2 = Math.round(new Date().getTime() / 1000);
				if (xhr.status == 200) {
					resolve(JSON.parse(xhr.responseText));
				} else {
					reject("Error occurred: " + xhr.status);
				}
			}
			};
		});
	}

	function mock() {
		createPopup(mockResult);
	}

	async function original() {
		try {
			const results = await speechSuperAPI();
			createPopup(results);
		} catch (error) {
			console.error(error);
		}
	}

	var btn = document.getElementById("btn");
	btn.onclick = function () {
		original();
		return false;
	};



	let audioContext;
	let recorder;
	var recording = false;
	var myBlob;

	const startRecordingButton = document.getElementById('startRecording');
	const stopRecordingButton = document.getElementById('stopRecording');

	startRecordingButton.addEventListener('click', startRecording);
	stopRecordingButton.addEventListener('click', stopRecording);

	function startRecording() {
		if(!recording){
			recording=true;
			console.log("Start");
			navigator.mediaDevices.getUserMedia({ audio: true })
				.then(stream => {
				audioContext = new AudioContext();
				const audioInput = audioContext.createMediaStreamSource(stream);
				recorder = new Recorder(audioInput, { numChannels: 1, sampleRate: 16000 }); 

				recorder.record();
				startRecordingButton.disabled = true;
				stopRecordingButton.disabled = false;
				})
				.catch(error => {
				console.error('Error accessing the microphone:', error);
				});
		}
	}

	function stopRecording() {
		if(recording){
			recording=false;
			console.log("Stop");
			recorder.stop();
			console.log(0, myBlob);
			recorder.exportWAV(function (blob) {
				console.log(1, myBlob);
				myBlob = blob;
				// const audioUrl = URL.createObjectURL(blob);
				// const downloadLink = document.createElement('a');
				// downloadLink.href = audioUrl;
				// downloadLink.download = 'recording_neww.wav';
				// downloadLink.click();
				recording=false;
				console.log(2, myBlob);
			});

			console.log(3, myBlob);			

			recorder.clear();
			startRecordingButton.disabled = false;
			stopRecordingButton.disabled = true;
		}
	}

	function downloadRecording(){
		if(myBlob){
			const targetRate = 16000;
			var downsampledBuffer = downsampleBuffer(myBlob, targetRate);
			console.log("Downsample", downsampledBuffer);
			var dataview = encodeWAVnew(downsampledBuffer, targetRate);
			console.log("PASS");
			myBlob = new Blob([dataview], { type: 'audio/wav' });
			const audioUrl = URL.createObjectURL(myBlob);
			const downloadLink = document.createElement('a');
			downloadLink.href = audioUrl;
			downloadLink.download = 'recording_neww.wav';
			downloadLink.click();
		}
		else{
			console.log("Empty Recording");
		}
	}

	function exportWAVnew(type) {
		var buffers = [];
		for (var channel = 0; channel < numChannels; channel++) {
			buffers.push(mergeBuffers(recBuffers[channel], recLength));
		}
		var interleaved = undefined;
		if (numChannels === 2) {
			interleaved = interleave(buffers[0], buffers[1]);
		} else {
			interleaved = buffers[0];
		}
		var dataview = encodeWAV(interleaved);
		var audioBlob = new Blob([dataview], { type: type });

		self.postMessage({ command: 'exportWAV', data: audioBlob });
    }

	function downsampleBuffer(buffer, rate) {
		const sampleRate = 44100;
		if (rate == sampleRate) {
			return buffer;
		}
		if (rate > sampleRate) {
			throw "downsampling rate should be smaller than original sample rate";
		}
		var sampleRateRatio = sampleRate / rate;
		var newLength = Math.round(buffer.length / sampleRateRatio);
		var result = new Float32Array(newLength);
		var offsetResult = 0;
		var offsetBuffer = 0;
		while (offsetResult < result.length) {
			var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
				// Use average value of skipped samples
			var accum = 0, count = 0;
			for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
				accum += buffer[i];
				count++;
			}
			result[offsetResult] = accum / count;
			// Or you can simply get rid of the skipped samples:
			// result[offsetResult] = buffer[nextOffsetBuffer];
			offsetResult++;
			offsetBuffer = nextOffsetBuffer;
		}
		return result;
	}

	function floatTo16BitPCM(output, offset, input) {
		console.log("input", input, input.length);
		for (var i = 0; i < input.length; i++, offset += 2) {
			var s = Math.max(-1, Math.min(1, input[i]));
			output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
		}
	}

	function writeString(view, offset, string) {
		for (var i = 0; i < string.length; i++) {
			view.setUint8(offset + i, string.charCodeAt(i));
		}
	}

	function encodeWAVnew(samples, sampleRate) {
		// console.log("Sample", samples, samples.length);
		console.log("Sample", samples, samples.size);

		const numChannels = 1;
		var buffer = new ArrayBuffer(44 + samples.size * 2);
		var view = new DataView(buffer);

		/* RIFF identifier */
		writeString(view, 0, 'RIFF');
		/* RIFF chunk length */
		view.setUint32(4, 36 + samples.size * 2, true);
		/* RIFF type */
		writeString(view, 8, 'WAVE');
		/* format chunk identifier */
		writeString(view, 12, 'fmt ');
		/* format chunk length */
		view.setUint32(16, 16, true);
		/* sample format (raw) */
		view.setUint16(20, 1, true);
		/* channel count */
		view.setUint16(22, numChannels, true);
		/* sample rate */
		view.setUint32(24, sampleRate, true);
		/* byte rate (sample rate * block align) */
		view.setUint32(28, sampleRate * 4, true);
		/* block align (channel count * bytes per sample) */
		view.setUint16(32, numChannels * 2, true);
		/* bits per sample */
		view.setUint16(34, 16, true);
		/* data chunk identifier */
		writeString(view, 36, 'data');
		/* data chunk length */
		view.setUint32(40, samples.size * 2, true);

		floatTo16BitPCM(view, 44, samples);

		return view;
	}


















	// let audioContext;
	// let recorder;
	// var recording = false;

	// const startRecordingButton = document.getElementById('startRecording');
	// const stopRecordingButton = document.getElementById('stopRecording');

	// startRecordingButton.addEventListener('click', startRecording);
	// stopRecordingButton.addEventListener('click', stopRecording);



	// // function __log(e, data) {
    // // 	log.innerHTML += "\n" + e + " " + (data || '');
  	// // }

	// var audio_context;
  	// // var recorder;

	// function startUserMedia(stream) {
	// 	var input = audio_context.createMediaStreamSource(stream);
	// 	// __log('Media stream created.');
	// 	console.log('Media stream created.');

	// 	// Uncomment if you want the audio to feedback directly
	// 	//input.connect(audio_context.destination);
	// 	//__log('Input connected to audio context destination.');
		
	// 	recorder = new Recorder(input);
	// 	// __log('Recorder initialised.');
	// 	console.log('Recorder initialised.');
	// }

	// function startRecording(button) {
	// 	if(!recording){
	// 		recording = true;
	// 		recorder && recorder.record();
	// 		startRecordingButton.disabled = true;
	// 		stopRecordingButton.disabled = false;
	// 		// button.disabled = true;
	// 		// button.nextElementSibling.disabled = false;
	// 		// __log('Recording...');
	// 		console.log('Recording...');
	// 	}
	// }

	// function stopRecording(button) {
	// 	if(recording){
	// 		recording = false;
	// 		recorder && recorder.stop();
	// 		startRecordingButton.disabled = false;
	// 		stopRecordingButton.disabled = true;
	// 		// button.disabled = true;
	// 		// button.previousElementSibling.disabled = false;
	// 		// __log('Stopped recording.');
	// 		console.log('Stopped recording.');

	// 		recorder.exportWAV(function(blob) {
	// 			const audioUrl = URL.createObjectURL(blob);
	// 			const downloadLink = document.createElement('a');
	// 			downloadLink.href = audioUrl;
	// 			downloadLink.download = 'new_record.wav';
	// 			downloadLink.click();
	// 			console.log('Download...');
	// 		});
			
	// 		// create WAV download link using audio data blob
	// 		// createDownloadLink();
			
	// 		recorder.clear();
	// 	}
	// }

	// function createDownloadLink() {
	// 	recorder && recorder.exportWAV(function(blob) {
	// 		const audioUrl = URL.createObjectURL(blob);
	// 		const downloadLink = document.createElement('a');
	// 		downloadLink.href = audioUrl;
	// 		downloadLink.download = 'new_record.wav';
	// 		downloadLink.click();
	// 	// var url = URL.createObjectURL(blob);
	// 	// var li = document.createElement('li');
	// 	// var au = document.createElement('audio');
	// 	// var hf = document.createElement('a');
		
	// 	// au.controls = true;
	// 	// au.src = url;
	// 	// hf.href = url;
	// 	// hf.download = new Date().toISOString() + '.wav';
	// 	// hf.innerHTML = hf.download;
	// 	// li.appendChild(au);
	// 	// li.appendChild(hf);
	// 	// recordingslist.appendChild(li);
	// 	});
	// }

	// window.onload = function init() {
	// 	try {
	// 	// webkit shim
	// 	window.AudioContext = window.AudioContext || window.webkitAudioContext;
	// 	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;
	// 	window.URL = window.URL || window.webkitURL;
		
	// 	audio_context = new AudioContext;
	// 	// __log('Audio context set up.');
	// 	// __log('navigator.getUserMedia ' + (navigator.getUserMedia ? 'available.' : 'not present!'));
	// 	console.log('Audio context set up.');
	// 	console.log('navigator.getUserMedia ' + (navigator.getUserMedia ? 'available.' : 'not present!'));
	// 	} catch (e) {
	// 	alert('No web audio support in this browser!');
	// 	}
		
	// 	navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
	// 	// __log('No live audio input: ' + e);
	// 	console.log('No live audio input: ' + e);
	// 	});
	// };

















	// function startRecording() {
	// 	if(!recording){
	// 		recording=true;
	// 		console.log("Start");
	// 		navigator.mediaDevices.getUserMedia({ audio: true })
	// 			.then(stream => {
	// 			audioContext = new AudioContext();
	// 			const audioInput = audioContext.createMediaStreamSource(stream);
	// 			recorder = new Recorder(audioInput, { numChannels: 1, sampleRate: 16000 }); 

	// 			recorder.record();
	// 			startRecordingButton.disabled = true;
	// 			stopRecordingButton.disabled = false;
	// 			})
	// 			.catch(error => {
	// 			console.error('Error accessing the microphone:', error);
	// 			});
	// 	}
	// }

	// function stopRecording() {
	// 	if(recording){
	// 		recording=false;
	// 		console.log("Stop");
	// 		recorder.stop();

	// 		recorder.exportWAV(function (b) {
	// 			console.log(b);

	// 		});
			
	// 			/*
	// 		recorder.exportWAV(function (blob) {
	// 			// downBuffer = downsampleBuffer(blob, 16000);
	// 			// downDataView = encodeWAVcustom(samples=downBuffer, numChannels=1, sampleRate=16000);
	// 			// const audioUrl = URL.createObjectURL(downDataView);
				
	// 			const audioUrl = URL.createObjectURL(blob);
	// 			const downloadLink = document.createElement('a');
	// 			downloadLink.href = audioUrl;
	// 			downloadLink.download = 'recording_samplee.wav';
	// 			downloadLink.click();
	// 			recording=false;
				
	// 			// downsampleAudio(blob=blob, targetSampleRate=16000);
	// 			// adjustSampleRate(blob=blob, targetSampleRate=16000)
	// 		});
	// 		*/
	// 		recorder.clear();
	// 		startRecordingButton.disabled = false;
	// 		stopRecordingButton.disabled = true;
	// 	}
	// }





	// function downsampleBuffer(buffer, rate) {
	// 	if (rate == sampleRate) {
	// 		return buffer;
	// 	}
	// 	if (rate > sampleRate) {
	// 		throw "downsampling rate show be smaller than original sample rate";
	// 	}
	// 	var sampleRateRatio = sampleRate / rate;
	// 	var newLength = Math.round(buffer.length / sampleRateRatio);
	// 	var result = new Float32Array(newLength);
	// 	var offsetResult = 0;
	// 	var offsetBuffer = 0;
	// 	while (offsetResult < result.length) {
	// 		var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
	// 			// Use average value of skipped samples
	// 		var accum = 0, count = 0;
	// 		for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
	// 			accum += buffer[i];
	// 			count++;
	// 		}
	// 		result[offsetResult] = accum / count;
	// 		// Or you can simply get rid of the skipped samples:
	// 		// result[offsetResult] = buffer[nextOffsetBuffer];
	// 		offsetResult++;
	// 		offsetBuffer = nextOffsetBuffer;
	// 	}
	// 	return result;
	// }

	// function writeString(view, offset, string) {
	// 	for (var i = 0; i < string.length; i++) {
	// 		view.setUint8(offset + i, string.charCodeAt(i));
	// 	}
	// }

	// function encodeWAVcustom(samples, numChannels, sampleRate) {
	// 	var buffer = new ArrayBuffer(44 + samples.length * 2);
	// 	var view = new DataView(buffer);

	// 	/* RIFF identifier */
	// 	writeString(view, 0, 'RIFF');
	// 	/* RIFF chunk length */
	// 	view.setUint32(4, 36 + samples.length * 2, true);
	// 	/* RIFF type */
	// 	writeString(view, 8, 'WAVE');
	// 	/* format chunk identifier */
	// 	writeString(view, 12, 'fmt ');
	// 	/* format chunk length */
	// 	view.setUint32(16, 16, true);
	// 	/* sample format (raw) */
	// 	view.setUint16(20, 1, true);
	// 	/* channel count */
	// 	view.setUint16(22, numChannels, true);
	// 	/* sample rate */
	// 	view.setUint32(24, sampleRate, true);
	// 	/* byte rate (sample rate * block align) */
	// 	view.setUint32(28, sampleRate * 4, true);
	// 	/* block align (channel count * bytes per sample) */
	// 	view.setUint16(32, numChannels * 2, true);
	// 	/* bits per sample */
	// 	view.setUint16(34, 16, true);
	// 	/* data chunk identifier */
	// 	writeString(view, 36, 'data');
	// 	/* data chunk length */
	// 	view.setUint32(40, samples.length * 2, true);

	// 	floatTo16BitPCM(view, 44, samples);

	// 	return view;
    // }


	// sample.html:385 Uncaught RangeError: Offset is outside the bounds of the DataView
    // at DataView.setUint8 (<anonymous>)
    // at writeString (sample.html:385:9)
    // at encodeWAVcustom (sample.html:394:3)
    // at sample.html:336:20
    // at Recorder.worker.onmessage (recorder.js:238:17)





	// // Function to adjust the sample rate of a .wav file
	// function adjustSampleRate(blob, targetSampleRate) {
	// const audioContext = new (window.AudioContext || window.webkitAudioContext)();
	// const audioElement = new Audio();
	// const fileReader = new FileReader();

	// fileReader.onload = function () {
	// 	audioElement.src = fileReader.result;

	// 	audioElement.onloadedmetadata = function () {
	// 	// const offlineContext = new OfflineAudioContext(
	// 	// 	audioElement.channels,
	// 	// 	audioElement.duration * targetSampleRate,
	// 	// 	targetSampleRate
	// 	// );
	// 	const offlineContext = new OfflineAudioContext(
	// 		2,
	// 		Math.floor(audioElement.duration * targetSampleRate),
	// 		targetSampleRate
	// 	);

	// 	const source = offlineContext.createBufferSource();
	// 	// const audioData = audioContext.createBuffer(
	// 	// 	audioElement.channels,
	// 	// 	audioElement.duration * audioElement.sampleRate,
	// 	// 	audioElement.sampleRate
	// 	// );
	// 	const audioData = audioContext.createBuffer(
	// 		1,
	// 		Math.floor(audioElement.duration * audioElement.sampleRate),
	// 		audioElement.sampleRate
	// 	);

	// 	source.buffer = audioData;

	// 	const audioDestination = offlineContext.destination;
	// 	source.connect(audioDestination);
	// 	source.start();

	// 	offlineContext.oncomplete = function (event) {
	// 		const outputBuffer = event.renderedBuffer;
	// 		const wavBlob = bufferToWav(outputBuffer);

	// 		// Callback with the adjusted sample rate .wav blob
	// 		// callback(wavBlob);
	// 		console.log("Blob");
	// 		console.log(typeof wavBlob);
	// 		console.log(wavBlob);
	// 		const audioUrl = URL.createObjectURL(wavBlob);
	// 		const downloadLink = document.createElement('a');
	// 		downloadLink.href = audioUrl;
	// 		downloadLink.download = 'recording_sample_adjust.wav';
	// 		downloadLink.click();
	// 		recording=false;
	// 	};

	// 	offlineContext.startRendering();
	// 	};

	// 	audioElement.onerror = function (error) {
	// 	console.error('Error loading audio:', error);
	// 	};
	// };

	// fileReader.onerror = function (error) {
	// 	console.error('Error reading file:', error);
	// };

	// fileReader.readAsDataURL(blob);
	// }

	// // Function to convert audio buffer to .wav blob
	// function bufferToWav(buffer) {
	// const numOfChannels = buffer.numberOfChannels;
	// const sampleRate = buffer.sampleRate;
	// const length = buffer.length;
	// const interleaved = new Float32Array(length * numOfChannels);
	// const view = new DataView(new ArrayBuffer(44 + interleaved.length * 2));
	// const channels = [];

	// for (let i = 0; i < numOfChannels; i++) {
	// 	channels.push(buffer.getChannelData(i));
	// }

	// for (let i = 0; i < length; i++) {
	// 	for (let j = 0; j < numOfChannels; j++) {
	// 	interleaved[i * numOfChannels + j] = channels[j][i];
	// 	}
	// }

	// let index = 0;
	// view.setUint32(index, 0x46464952, true); // "RIFF" in ASCII
	// index += 4;
	// view.setUint32(index, 36 + interleaved.length * 2, true); // file length - 8
	// index += 4;
	// view.setUint32(index, 0x45564157, true); // "WAVE" in ASCII
	// index += 4;
	// view.setUint32(index, 0x20746d66, true); // "fmt " in ASCII
	// index += 4;
	// view.setUint32(index, 16, true); // format length
	// index += 4;
	// view.setUint16(index, 1, true); // PCM format
	// index += 2;
	// view.setUint16(index, numOfChannels, true); // number of channels
	// index += 2;
	// view.setUint32(index, sampleRate, true); // sample rate
	// index += 4;
	// view.setUint32(index, sampleRate * 2 * numOfChannels, true); // byte rate
	// index += 4;
	// view.setUint16(index, numOfChannels * 2, true); // block align
	// index += 2;
	// view.setUint16(index, 16, true); // bits per sample
	// index += 2;
	// view.setUint32(index, 0x61746164, true); // "data" in ASCII
	// index += 4;
	// view.setUint32(index, interleaved.length * 2, true); // data length
	// index += 4;

	// interleaved.forEach(function (sample) {
	// 	view.setInt16(index, sample * 0x7fff, true);
	// 	index += 2;
	// });

	// return new Blob([view], { type: 'audio/wav' });
	// }




	// function downsampleAudio(blob, targetSampleRate) {
	// 	var downsampledBlob = blob;
	// 	console.log("Blob");
	// 	console.log(typeof downsampledBlob);
	// 	console.log(downsampledBlob);
	// 	const audioUrl = URL.createObjectURL(downsampledBlob);
	// 	const downloadLink = document.createElement('a');
	// 	downloadLink.href = audioUrl;
	// 	downloadLink.download = 'recording_sample_2.wav';
	// 	downloadLink.click();
	// 	recording=false;
	// 	// const audioContext = new (window.AudioContext || window.webkitAudioContext)();
	// 	// const fileReader = new FileReader();

	// 	// fileReader.onload = function () {
	// 	// 	audioContext.decodeAudioData(this.result, function (decodedData) {
	// 	// 	const originalSampleRate = decodedData.sampleRate;
	// 	// 	const channels = decodedData.numberOfChannels;
	// 	// 	const frameCount = decodedData.length;

	// 	// 	const audioBuffer = audioContext.createBuffer(
	// 	// 		channels,
	// 	// 		frameCount * targetSampleRate / originalSampleRate,
	// 	// 		targetSampleRate
	// 	// 	);

	// 	// 	for (let channel = 0; channel < channels; channel++) {
	// 	// 		const inputData = decodedData.getChannelData(channel);
	// 	// 		const outputData = audioBuffer.getChannelData(channel);

	// 	// 		for (let i = 0; i < audioBuffer.length; i++) {
	// 	// 		const oldIndex = Math.floor(i * originalSampleRate / targetSampleRate);
	// 	// 		outputData[i] = inputData[oldIndex];
	// 	// 		}
	// 	// 	}

	// 	// 	// Do something with the downsampled audio buffer here
	// 	// 	// For example, you can create a new Blob with the downsampled data
	// 	// 	const downsampledBlob = new Blob([audioBuffer], { type: 'audio/wav' });

	// 	// 	// Use the downsampledBlob as needed
	// 	// 	console.log('Downsampled Blob:', downsampledBlob);

	// 	// 	// return downsampledBlob;

	// 	// 	console.log("Blob");
	// 	// 		console.log(typeof downsampledBlob);
	// 	// 		console.log(downsampledBlob);
	// 	// 		const audioUrl = URL.createObjectURL(downsampledBlob);
	// 	// 		const downloadLink = document.createElement('a');
	// 	// 		downloadLink.href = audioUrl;
	// 	// 		downloadLink.download = 'recording_sample.wav';
	// 	// 		downloadLink.click();
	// 	// 		recording=false;
			
	// 	// 	});
	// 	// };

	// 	// fileReader.readAsArrayBuffer(blob);
	// }


</script>