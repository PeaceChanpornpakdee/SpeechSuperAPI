<script type="text/javascript" src="sha.js"></script>
<script type="text/javascript" src="key.js"></script>
<script type="text/javascript" src="mockdata.js"></script>
<!-- <script src="https://cdn.rawgit.com/mattdiamond/Recorderjs/08e7abd9/dist/recorder.js"></script> -->
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<h2>-----------javascript http sample-----------</h2>
<form action="" method="post" enctype="multipart/form-data" id="form" name="form_en">
<pre>
refText: Test One Two Three
</pre>
<input type="file" name="audio" id="picpath" style="display:none" onChange="document.form_en.path.value=this.value">
<input name="path" readonly placeholder="Please choose your audio file" style="width:350px"> 
<input type="button" value="Browse" onclick="document.form_en.picpath.click()">
<pre>
<input type="submit" value="Submit" id ="btn" style="margin-left: 56px;">
</pre>
</form>

<button type="button" onclick="mock()">Mock Response</button>
<pre></pre>

<button type="button" class="recording-button" id="startRecording" onclick="startRecording()">Start Recording</button>
<button type="button" class="recording-button" id="stopRecording"  onclick="stopRecording()" disabled>Stop Recording</button>
<pre></pre>

<button type="button" onclick="downloadRecording()">Download</button>
<pre></pre>

<div id="firstclassenglish-popup"></div>
<script>

	function createPopup(results){
		var popup = document.getElementById("firstclassenglish-popup"); 
		console.log("Result", results);
		const title = document.createElement('h3');
		title.textContent = 'Pronunciation Score';
		popup.appendChild(title);
		createPowerbar(container=popup, topic='Fluency', percent=results.result.fluency);
		createPowerbar(container=popup, topic='Integrity', percent=results.result.integrity);
		createPowerbar(container=popup, topic='Rhythm', percent=results.result.rhythm);
		createTable(container=popup, results=results);
	}

	function createPowerbar(container, topic, percent) {
		const powerBarContainer = document.createElement('div');
		powerBarContainer.classList.add('power-bar-container');

		const powerBarBackground = document.createElement('div');
		powerBarBackground.classList.add('power-bar-background')

		const powerBar = document.createElement('div');
		powerBar.classList.add('power-bar')
		powerBar.style.width = percent + '%';

		const percentText = document.createElement('div');
		percentText.style.padding = '7px 4px';
		percentText.style.width = '12px'
		percentText.textContent = percent;

		const topicText = document.createElement('div');
		topicText.classList.add('power-bar-topic')
		topicText.textContent = topic;

		container.appendChild(powerBarContainer);
		powerBarContainer.appendChild(topicText);
		powerBarContainer.appendChild(powerBarBackground);
		powerBarBackground.appendChild(powerBar);
		powerBarContainer.appendChild(percentText);
	}

	function createTable(container, results){

		var table = document.createElement('table');

		var tableHead = document.createElement('thead');
		var tableBody = document.createElement('tbody');

		var headerRow = document.createElement('tr');
		var headers = ['Word', 'Score', ''];

		headers.forEach(headerText => {
			const th = document.createElement('th');
			th.textContent = headerText;
			headerRow.appendChild(th);
		});

		tableHead.appendChild(headerRow);
		table.appendChild(tableHead);

		const wordResult = results.result.words;

		for (let i = 0; i < wordResult.length; i++) {
			const row = document.createElement('tr');

			console.log(wordResult[i].word, wordResult[i].scores.overall);

			const cell1 = document.createElement('td');
			cell1.textContent = wordResult[i].word;

			const cell2 = document.createElement('td');
			cell2.textContent = wordResult[i].scores.overall;

			const cell3 = document.createElement('td');
			const arrowIcon = document.createElement('i');
			arrowIcon.classList.add('fas', 'fa-chevron-down'); 
			cell3.appendChild(arrowIcon);

			row.appendChild(cell1);
			row.appendChild(cell2);
			row.appendChild(cell3);
			row.addEventListener('click', () => toggleRows(`main-row-${i + 1}`, arrowIcon));

			row.classList.add(`main-row-${i + 1}`);

			if (i%2 === 0)  row.classList.add('main-even-row');
			else            row.classList.add('main-odd-row');

			tableBody.appendChild(row);

			const phonemes = wordResult[i].phonemes;

			for (let j = 0; j < phonemes.length; j++) {
				const subRow = document.createElement('tr');

				const cell11 = document.createElement('td');
				cell11.textContent = phonemes[j].phoneme;
				subRow.appendChild(cell11); 

				const cell22 = document.createElement('td');
				cell22.textContent = phonemes[j].pronunciation;
				subRow.appendChild(cell22);

				if(phonemes[j].pronunciation < 50){
					cell11.style.color = '#D90000';
					cell22.style.color = '#D90000';
				}

				console.log(phonemes[j].phoneme, phonemes[j].pronunciation);

				const cell33 = document.createElement('td');
				subRow.appendChild(cell33);

				subRow.classList.add(`main-row-${i + 1}-sub`);
				subRow.classList.add('hidden');

				if (j%2 === 0)  subRow.classList.add('even-row');
				else            subRow.classList.add('odd-row');
				
				tableBody.appendChild(subRow);
			}
		}

		table.appendChild(tableBody);
		container.appendChild(table);
	}

	function toggleRows(mainRowClass, arrowIcon) {
		const rowsToToggle = document.querySelectorAll(`.${mainRowClass}-sub`);
		rowsToToggle.forEach(row => {
			row.classList.toggle('show');
			row.classList.toggle('hidden');
		});	

		arrowIcon.classList.toggle('fa-chevron-down');
		arrowIcon.classList.toggle('fa-chevron-up');

		const otherMainRows = document.querySelectorAll(`tr[class^="main-row-"]:not(.${mainRowClass}):not([class*="sub"])`);

		otherMainRows.forEach(row => {
			const subRows = document.querySelectorAll(`.${row.classList[0]}-sub`);
			subRows.forEach(subRow => {
				subRow.classList.remove('show');
				subRow.classList.add('hidden');
			});
		});

		const otherArrowIcons = document.querySelectorAll(`tr[class^="main-row-"]:not(.${mainRowClass}) td:last-child i`);
		otherArrowIcons.forEach(icon => {
			icon.classList.add('fa-chevron-down');
			icon.classList.remove('fa-chevron-up');
		});
	}

	var baseUrl = "https://api.speechsuper.com/";

	var appKey = Key.appKey;
	var secretKey = Key.secretKey;

	var coreType = "sent.eval"; 
	// var refText = "Supermarket";
	var refText = "Test One Two Three";
	var audioType = "wav"; 
	var sampleRate = 16000;
	var userId = "guest";

	var url = baseUrl + coreType;
	
	var getConnectSig = function () {
		var timestamp = new Date().getTime().toString();
		var sig = new jsSHA(appKey + timestamp + secretKey, 'TEXT').getHash("SHA-1", "HEX");
		return { sig: sig, timestamp: timestamp };
	}
	var getStartSig = function () {
		var timestamp = new Date().getTime().toString();
		var sig = new jsSHA(appKey + timestamp + userId + secretKey, 'TEXT').getHash("SHA-1", "HEX");
		return { sig: sig, timestamp: timestamp, userId: userId };
	}
	var createUUID = (function (uuidRegEx, uuidReplacer) {
		return function () {
			return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
		};
	})(/[xy]/g, function (c) {
		var r = Math.random() * 16 | 0,
			v = c == "x" ? r : (r & 3 | 8);
		return v.toString(16);
	});
	var connectSig = getConnectSig();
	var startSig = getStartSig();
	var params = {
		connect: {
			cmd: "connect",
			param: {
				sdk: {
					version: 16777472,
					source: 9,
					protocol: 2
				},
				app: {
					applicationId: appKey,
					sig: connectSig.sig,
					timestamp: connectSig.timestamp
				}
			}
		},
		start: {
			cmd: "start",
			param: {
				app: {
					applicationId: appKey,
					sig: startSig.sig,
					userId: startSig.userId,
					timestamp: startSig.timestamp
				},
				audio: {
					audioType: audioType,
					sampleRate: sampleRate,
					channel: 1,
					sampleBytes: 2
				},
				request: {
					coreType: coreType,
					refText: refText,
					tokenId: createUUID()
				}
			}
		}
	};

	async function speechSuperAPI() {
		return new Promise(function(resolve, reject) {
			var fd = new FormData(document.getElementById("form"));
			fd.append("text", JSON.stringify(params));
			var xhr = new XMLHttpRequest();
			xhr.open("post", url);
			xhr.setRequestHeader("Request-Index", "0");
			xhr.send(fd);
			var t1, t2;
			t1 = Math.round(new Date().getTime() / 1000);
			xhr.onreadystatechange = function() {
			if (xhr.readyState == 4) {
				t2 = Math.round(new Date().getTime() / 1000);
				if (xhr.status == 200) {
					resolve(JSON.parse(xhr.responseText));
				} else {
					reject("Error occurred: " + xhr.status);
				}
			}
			};
		});
	}

	function mock() {
		createPopup(mockResult);
	}

	async function original() {
		try {
			const results = await speechSuperAPI();
			createPopup(results);
		} catch (error) {
			console.error(error);
		}
	}

	var btn = document.getElementById("btn");
	btn.onclick = function () {
		original();
		return false;
	};



	let audioContext;
	let recorder;
	var recording = false;

	const startRecordingButton = document.getElementById('startRecording');
	const stopRecordingButton = document.getElementById('stopRecording');

	startRecordingButton.addEventListener('click', startRecording);
	stopRecordingButton.addEventListener('click', stopRecording);

	function startRecording() {
		if(!recording){
			recording=true;
			console.log("Start");
			navigator.mediaDevices.getUserMedia({ audio: true })
				.then(stream => {
				audioContext = new AudioContext();
				const audioInput = audioContext.createMediaStreamSource(stream);
				recorder = new Recorder(audioInput, { numChannels: 1, sampleRate: 16000 }); 

				recorder.record();
				startRecordingButton.disabled = true;
				stopRecordingButton.disabled = false;
				})
				.catch(error => {
				console.error('Error accessing the microphone:', error);
				});
		}
	}

	function stopRecording() {
		if(recording){
			recording=false;
			console.log("Stop");
			recorder.stop();
			recorder.exportWAV(function (blob) {
				const audioUrl = URL.createObjectURL(blob);
				const downloadLink = document.createElement('a');
				downloadLink.href = audioUrl;
				downloadLink.download = 'recording_16000.wav';
				downloadLink.click();
				recording=false;
			});		

			recorder.clear();
			startRecordingButton.disabled = false;
			stopRecordingButton.disabled = true;
		}
	}

	(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Recorder = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	"use strict";

	module.exports = require("./recorder").Recorder;

	},{"./recorder":2}],2:[function(require,module,exports){
	'use strict';

	var _createClass = (function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	})();

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Recorder = undefined;

	var _inlineWorker = require('inline-worker');

	var _inlineWorker2 = _interopRequireDefault(_inlineWorker);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	var Recorder = exports.Recorder = (function () {
		function Recorder(source, cfg) {
			var _this = this;

			_classCallCheck(this, Recorder);

			this.config = {
				bufferLen: 4096,
				numChannels: 2,
				mimeType: 'audio/wav'
			};
			this.recording = false;
			this.callbacks = {
				getBuffer: [],
				exportWAV: []
			};

			Object.assign(this.config, cfg);
			this.context = source.context;
			this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels);

			this.node.onaudioprocess = function (e) {
				if (!_this.recording) return;

				var buffer = [];
				for (var channel = 0; channel < _this.config.numChannels; channel++) {
					buffer.push(e.inputBuffer.getChannelData(channel));
				}
				_this.worker.postMessage({
					command: 'record',
					buffer: buffer
				});
			};

			source.connect(this.node);
			this.node.connect(this.context.destination); //this should not be necessary

			var self = {};
			this.worker = new _inlineWorker2.default(function () {
				var recLength = 0,
					recBuffers = [],
					sampleRate = undefined,
					numChannels = undefined;

				self.onmessage = function (e) {
					switch (e.data.command) {
						case 'init':
							init(e.data.config);
							break;
						case 'record':
							record(e.data.buffer);
							break;
						case 'exportWAV':
							exportWAV(e.data.type);
							break;
						case 'getBuffer':
							getBuffer();
							break;
						case 'clear':
							clear();
							break;
					}
				};

				function init(config) {
					sampleRate = config.sampleRate;
					numChannels = config.numChannels;
					initBuffers();
				}

				function record(inputBuffer) {
					for (var channel = 0; channel < numChannels; channel++) {
						recBuffers[channel].push(inputBuffer[channel]);
					}
					recLength += inputBuffer[0].length;
				}

				function downsampleBuffer(buffer, rate) {
					if (rate == sampleRate) {
						return buffer;
					}
					if (rate > sampleRate) {
						throw "downsampling rate should be smaller than original sample rate";
					}
					var sampleRateRatio = sampleRate / rate;
					var newLength = Math.round(buffer.length / sampleRateRatio);
					var result = new Float32Array(newLength);
					var offsetResult = 0;
					var offsetBuffer = 0;
					while (offsetResult < result.length) {
						var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
						// Use average value of skipped samples
						var accum = 0, count = 0;
						for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
							accum += buffer[i];
							count++;
						}
						result[offsetResult] = accum / count;
						// Or you can simply get rid of the skipped samples:
						// result[offsetResult] = buffer[nextOffsetBuffer];
						offsetResult++;
						offsetBuffer = nextOffsetBuffer;
					}
					return result;
				}

				function exportWAV(type) {
					var buffers = [];
					for (var channel = 0; channel < numChannels; channel++) {
						buffers.push(mergeBuffers(recBuffers[channel], recLength));
					}
					var interleaved = undefined;
					if (numChannels === 2) {
						interleaved = interleave(buffers[0], buffers[1]);
					} else {
						interleaved = buffers[0];
					}
					const targetRate = 16000;
					var downsampledBuffer = downsampleBuffer(interleaved, targetRate);
					var dataview = encodeWAV(downsampledBuffer);
					// var dataview = encodeWAV(interleaved);
					var audioBlob = new Blob([dataview], { type: type });

					self.postMessage({ command: 'exportWAV', data: audioBlob });
				}

				function getBuffer() {
					var buffers = [];
					for (var channel = 0; channel < numChannels; channel++) {
						buffers.push(mergeBuffers(recBuffers[channel], recLength));
					}
					self.postMessage({ command: 'getBuffer', data: buffers });
				}

				function clear() {
					recLength = 0;
					recBuffers = [];
					initBuffers();
				}

				function initBuffers() {
					for (var channel = 0; channel < numChannels; channel++) {
						recBuffers[channel] = [];
					}
				}

				function mergeBuffers(recBuffers, recLength) {
					var result = new Float32Array(recLength);
					var offset = 0;
					for (var i = 0; i < recBuffers.length; i++) {
						result.set(recBuffers[i], offset);
						offset += recBuffers[i].length;
					}
					return result;
				}

				function interleave(inputL, inputR) {
					var length = inputL.length + inputR.length;
					var result = new Float32Array(length);

					var index = 0,
						inputIndex = 0;

					while (index < length) {
						result[index++] = inputL[inputIndex];
						result[index++] = inputR[inputIndex];
						inputIndex++;
					}
					return result;
				}

				function floatTo16BitPCM(output, offset, input) {
					for (var i = 0; i < input.length; i++, offset += 2) {
						var s = Math.max(-1, Math.min(1, input[i]));
						output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
					}
				}

				function writeString(view, offset, string) {
					for (var i = 0; i < string.length; i++) {
						view.setUint8(offset + i, string.charCodeAt(i));
					}
				}

				function encodeWAV(samples) {
					var buffer = new ArrayBuffer(44 + samples.length * 2);
					var view = new DataView(buffer);
					const newSampleRate = 16000;

					/* RIFF identifier */
					writeString(view, 0, 'RIFF');
					/* RIFF chunk length */
					view.setUint32(4, 36 + samples.length * 2, true);
					/* RIFF type */
					writeString(view, 8, 'WAVE');
					/* format chunk identifier */
					writeString(view, 12, 'fmt ');
					/* format chunk length */
					view.setUint32(16, 16, true);
					/* sample format (raw) */
					view.setUint16(20, 1, true);
					/* channel count */
					view.setUint16(22, numChannels, true);
					/* sample rate */
					view.setUint32(24, newSampleRate, true);
					/* byte rate (sample rate * block align) */
					view.setUint32(28, newSampleRate * 4, true);
					/* block align (channel count * bytes per sample) */
					view.setUint16(32, numChannels * 2, true);
					/* bits per sample */
					view.setUint16(34, 16, true);
					/* data chunk identifier */
					writeString(view, 36, 'data');
					/* data chunk length */
					view.setUint32(40, samples.length * 2, true);

					floatTo16BitPCM(view, 44, samples);

					return view;
				}
			}, self);

			this.worker.postMessage({
				command: 'init',
				config: {
					sampleRate: this.context.sampleRate,
					numChannels: this.config.numChannels
				}
			});

			this.worker.onmessage = function (e) {
				var cb = _this.callbacks[e.data.command].pop();
				if (typeof cb == 'function') {
					cb(e.data.data);
				}
			};
		}

		_createClass(Recorder, [{
			key: 'record',
			value: function record() {
				this.recording = true;
			}
		}, {
			key: 'stop',
			value: function stop() {
				this.recording = false;
			}
		}, {
			key: 'clear',
			value: function clear() {
				this.worker.postMessage({ command: 'clear' });
			}
		}, {
			key: 'getBuffer',
			value: function getBuffer(cb) {
				cb = cb || this.config.callback;
				if (!cb) throw new Error('Callback not set');

				this.callbacks.getBuffer.push(cb);

				this.worker.postMessage({ command: 'getBuffer' });
			}
		}, {
			key: 'exportWAV',
			value: function exportWAV(cb, mimeType) {
				mimeType = mimeType || this.config.mimeType;
				cb = cb || this.config.callback;
				if (!cb) throw new Error('Callback not set');

				this.callbacks.exportWAV.push(cb);

				this.worker.postMessage({
					command: 'exportWAV',
					type: mimeType
				});
			}
		}], [{
			key: 'forceDownload',
			value: function forceDownload(blob, filename) {
				var url = (window.URL || window.webkitURL).createObjectURL(blob);
				var link = window.document.createElement('a');
				link.href = url;
				link.download = filename || 'output.wav';
				var click = document.createEvent("Event");
				click.initEvent("click", true, true);
				link.dispatchEvent(click);
			}
		}]);

		return Recorder;
	})();

	exports.default = Recorder;

	},{"inline-worker":3}],3:[function(require,module,exports){
	"use strict";

	module.exports = require("./inline-worker");
	},{"./inline-worker":4}],4:[function(require,module,exports){
	(function (global){
	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);

	var InlineWorker = (function () {
	function InlineWorker(func, self) {
		var _this = this;

		_classCallCheck(this, InlineWorker);

		if (WORKER_ENABLED) {
			var functionBody = func.toString().trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1];
			var url = global.URL.createObjectURL(new global.Blob([functionBody], { type: "text/javascript" }));

			return new global.Worker(url);
		}

		this.self = self;
		this.self.postMessage = function (data) {
			setTimeout(function () {
				_this.onmessage({ data: data });
			}, 0);
		};

		setTimeout(function () {
			func.call(self);
		}, 0);
	}

	_createClass(InlineWorker, {
		postMessage: {
			value: function postMessage(data) {
				var _this = this;

				setTimeout(function () {
				_this.self.onmessage({ data: data });
				}, 0);
			}
		}
	});

	return InlineWorker;
	})();

	module.exports = InlineWorker;
	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}]},{},[1])(1)
	});

</script>